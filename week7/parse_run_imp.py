from interp_imp import Program, Block, Decl, VarDecl, \
                       Assign, Ifnz, Whilenz, Print, Stmt, \
                       Add, Mul, Sub, Div, Neg, Name, Lit, Expr, \
                       run

from lark import Lark, Token, ParseTree, Transformer
from lark.exceptions import VisitError
from pathlib import Path

parser = Lark(Path('imp.lark').read_text(),start='block',ambiguity='explicit')
#for checking against ambiguity:
#parser = Lark(Path('imp.lark').read_text(),start='block',parser='lalr',strict='True')

class ParseError(Exception):
    pass

def parse(s:str) -> ParseTree:
    try:
        return parser.parse(s)
    except Exception as e:
        raise ParseError(e)

class AmbiguousParse(Exception):
    pass

class ToProgram(Transformer[Token,Program]):
    '''Defines a transformation from a parse tree into an AST'''
    # This is structured as a "fold" over the parse tree.
    # There is a method for each named ("aliased") rule in the grammar,
    # invoked on nodes generated by that rule. 
    # The args are the _result_ of recursively 
    # applying the transformer to the children of the node
    # (we do not have to write the recursive calls explicitly).
    # For leaf nodes, the argument is a Token; the string that
    # actually makes up the token is in the .value field.
    # (We cheat by declaring the args as tuples rather than lists, since
    # this let's us be more precise about the types of the elements.)
    # Fail if tree contains ambiguity markers
    def block(self,args:tuple[list[Decl],list[Stmt]]) -> Block:
        return Block(args[0],args[1])
    def decls(self,args:list[Decl]) -> list[Decl]:
        return args
    def vardecl(self,args:tuple[Token,Expr]) -> Decl:
        return VarDecl(args[0].value,args[1])
    def stmts(self,args:list[Stmt]) -> list[Stmt]:
        return args
    def assign(self,args:tuple[Token,Expr]) -> Stmt:
        return Assign(args[0].value,args[1])
    def ifnz(self,args:tuple[Expr,Stmt,Stmt]) -> Stmt:
        return Ifnz(args[0],args[1],args[2])
    def whilenz(self,args:tuple[Expr,Stmt]) -> Stmt:
        return Whilenz(args[0],args[1])
    def print_(self,args:tuple[Expr]) -> Stmt:
        return Print(args[0])
    def plus(self, args:tuple[Expr,Expr]) -> Expr:
        return Add(args[0],args[1])
    def times(self, args:tuple[Expr,Expr]) -> Expr:
        return Mul(args[0],args[1])
    def minus(self, args:tuple[Expr,Expr]) -> Expr:
        return Sub(args[0],args[1])
    def divide(self, args:tuple[Expr,Expr]) -> Expr:
        return Div(args[0],args[1])
    def neg(self, args:tuple[Expr]) -> Expr:
        return Neg(args[0])
    def id(self, args:tuple[Token]) -> Expr:
        return Name(args[0].value)
    def int(self,args:tuple[Token]) -> Expr:
        return Lit(int(args[0].value))
    def _ambig(self,_) -> Expr:    # ambiguity marker
        raise AmbiguousParse()


def genAST(t:ParseTree) -> Program:
    '''Applies the transformer to convert a parse tree into an AST'''
    # boilerplate to catch potential ambiguity error raised by transformer
    try:
        return ToProgram().transform(t)               
    except VisitError as e:
        if isinstance(e.orig_exc,AmbiguousParse):
            raise AmbiguousParse()
        else:
            raise e

def driver():
    while True:
        try:
            s = input('program: ')
            t = parse(s)
            print("raw:", t)    
            print("pretty:")
            print(t.pretty())
            ast = genAST(t)
            print("raw AST:", repr(ast))  # use repr() to avoid str() pretty-printing
            run(ast)                      # pretty-prints and executes the AST
        except AmbiguousParse:
            print("ambiguous parse")                
        except ParseError as e:
            print("parse error:")
            print(e)
        except EOFError:
            break

driver()

